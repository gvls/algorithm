##  处理散列冲突
减少和解决冲突 : 当`f(keyA) == f(keyB)` 时，出现冲突，keyA 和keyB 同义

###   开放地址法/线性探测法
若发生冲突，去寻找下一个空的散列地址 插入
`f(key) = ( f(key)+d ) mod m (d : 1 ~ m-1)` 

* 堆积 
由于出现冲突，当前需要找一个空位置，该空位置可能是未来某个元素要插入时的位置

* 二次探测法
d 取 1^2, -1^2, 2^2, -2^2, ...
出现冲突后，可以在前面插入
平方是为了不让关键字聚集到一个位置

* 随机探测法
d 取 随机数



###   再散列函数法
事先准备多个散列函数
当发生冲突，换一个散列函数计算，不断重复，直到解决冲突



###   链地址法
把所有冲突的同义关键字存储到一个单链表
散列表只存储链表的头指针



###   公共溢出区
用一个溢出表存储冲突的关键字
