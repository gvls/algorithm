##  next
当 S的元素`i` 与 T的元素`j` 匹配失败，`j`退回到`next[j]` 
```shell
next[j]
```

next array 的元素 :   一一对应 T 的元素
next array 的值   =   T 的当前元素**之前的元素**匹配 **T 的前缀**的数量 + 1

###   求`next[]`的值
1. T 和 T 自己进行`KMP`匹配（`next[]`会求出后在被使用）
2. 查找 T 的第 `j` 位置 前面的序列 和 T 开头的序列 相等的序列
3. `next[j]` 的值为 T开头的序列的 下一个位置



###   `next[]` 的改进
* 问题 
当 T 在`j`匹配失败后，`j`会跳到`next[j]`，这时假若`j`位置的元素和`next[j]`位置的元素一样的话，T 在`next[j]`位置一定会匹配失败，造成重复判断。

* 解决
旧步骤：当前 T 的`i`与 T 的`j`匹配成功后`i++`、`j++`、更新`next[i]=j`
新步骤：当前 T 的`i`与 T 的`j`匹配成功后`i++`、`j++`、这时`T[i]`若等于`T[j]`则`next[i]=next[j]`，若不等则`next[i]=j`
